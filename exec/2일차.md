### ts 기본 문법
- 객체 리터럴은 잉여 속성 검사가 있음.
```
type A = { hello: string };
const a: A = { hello: 'world', why: 'error' }; //잉여 속성 검사 실행되어 에러 발생

const b = { hello: 'world', why: 'error' }; //변수로 선언하고
const c: A = b; //타이핑하면 잉여 속성 검사를 안해서 에러 발생하지 않음
```

- void 타입은 return값을 사용하지 안 겠다는 뜻(메서드나 매개변수에서는 리턴값 사용 가능, but 조심해야 함)
```
function a(): void {
  //return '3'; --> 리턴값이 있으면 에러 발생
  //return undefined --> 가능
  //return null --> 에러 발생
  return;
}

declare function forEach<T>(arr: T[], callback: (el: T) => undefined): void;
// declare function forEach<T>(arr: T[], callback: (el: T) => void): void;

let target: number[] = [];
//return 값이 undefined일 때는 에러 발생. void일 땐, 에러 발생하지 않음.
forEach([1, 2, 3], el => target.push(el));

interface A {
    talk: () => void;
}
const a: A = {
    talk() { return 3; }
}
```

- 타입만 선언하고 싶을 때 declare(구현은 다른 파일에 있어야 함)
```
// 외부에서 만들어진 것을 타입 선언할 때, declare 사용.
declare const a: string;
declare function a(x: number): number;
declare class A {}

// 추후 declare module, declare global, declare namespace도 배움
```

- 타입간 대입 가능 표 (초록색 V는 useStrict 모드에서 X)

- 타입 가드
```
function numOrStr(a: number | string) {
  if (typeof a === 'string') {
    a.split(',');  
  } else {
    a.toFixed(1);
  }
}

function numOrNumArr(a: number | number[]) {
  if (Array.isArray(a)) { <!--  number[] -->
    a.slice(1);  
  } else { <!--  number -->
    a.toFixed(1);
  }
}



class A{
  aaa() {}
}
class B{
  bbb() {}
}
function aOrB(param: A | B){ <!-- class는 그 자체로 타입이 될 수 있다. 인스턴스의 타이핑은 클래스 이름으로 한다. -->
  if(param instanceof A){
    param.aaa();
  }
}
aOrB(new A()); <!-- aOrM(A) --> 에러 발생. -->
aOrB(new B());



type B = { type: 'b', bbb: string };
type C = { type: 'c', ccc: string };
type D = { type: 'd', ddd: string };
type A = B | C | D;
function typeCheck(a: A) {
  <!-- 값으로 구분 --> 객체 생성 시, 타입으로 라벨링하면 좋다. -->
  if (a.type === 'b') {
    a.bbb;
  } else if (a.type === 'c') {
    a.ccc;
  } else {
    a.ddd;
  }

  <!-- 속성명으로 구분 -->
  if ('bbb' in a) {
    a.type;  <!-- a: B -->
  } else if ('ccc' in a) {
    a.type; <!-- a: C -->
  } else {
    a.type; <!-- a: D -->
  }
}



interface Cat { meow: number }
interface Dog { bow: number }
function catOrDog(a: Cat | Dog): a is Dog {
  <!-- 타입 판별을 직접 만들어야 함. -->
  if ((a as Cat).meow) { return false }
  return true;
}
<!-- 타입을 구분해주는 커스텀 함수를 직접 만들 수 있음. -->
const cat: Cat | Dog = { meow: 3 }
if (catOrDog(cat)) {
    console.log(cat.meow);
}
if ('meow' in cat) {
    console.log(cat.meow);
}



const isRejected = (input: PromiseSettledResult<unknown>): input is PromiseRejectedResult => input.status === 'rejected';

const isFulfilled = <T>(input: PromiseSettledResult<T>): input is PromiseFulfilledResult<T> => input.status === 'fulfilled';

const promises = await Promise.allSettled([Promise.resolve('a'), Promise.resolve('b')]);
const errors = promises.filter(isRejected);
 <!-- const errors = promises.filter(isFulfilled); -->

export {};
```